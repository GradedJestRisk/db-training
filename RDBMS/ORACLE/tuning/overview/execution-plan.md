# Execution plan

## 5 ways to get it 

> - execute the EXPLAIN PLAN statement and then query the table where the output was written.
> - query a dynamic performance view showing the execution plans cached in the library cache.
> - use Real-time Monitoring to get information about SQL statements being executed or that just completed.
> - query an Automatic Workload Repository (AWR) or Statspack table, showing the execution plans stored in the repository.
>  - activate a tracing facility providing execution plans.

## EXPLAIN

### Generate

We can specify any table to store it.
By default, we use `plan_table` which is a global temporary table.


Without `gather_plan_statistics`, we only get parsing information.
With it, we get execution information. 

```oracle
EXPLAIN PLAN
SET statement_id = 'count-simple'
INTO plan_table
FOR
SELECT /*+ gather_plan_statistics */
    COUNT(*) 
FROM simple_table;
```

### Display

From table
```oracle
SELECT 
    pln.operation,
    pln.object_name,
    pln.cost,
    pln.cardinality,
    pln.bytes,
    pln.cpu_cost,
    pln.io_cost,
    pln.temp_space,
    'plan_table=>'
    ,pln.*
FROM plan_table pln
WHERE statement_id =  'count-simple'
ORDER BY plan_id, id
```

By using function
```oracle
SELECT * 
FROM table(dbms_xplan.display);
```

You get
```text
Plan hash value: 1067509040
 
---------------------------------------------------------------------------
| Id  | Operation          | Name         | Rows  | Cost (%CPU)| Time     |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |              |     1 |     3   (0)| 00:00:01 |
|   1 |  SORT AGGREGATE    |              |     1 |            |          |
|   2 |   TABLE ACCESS FULL| SIMPLE_TABLE |  1001 |     3   (0)| 00:00:01 |
---------------------------------------------------------------------------
 
Note
-----
   - dynamic statistics used: dynamic sampling (level=2)

```

## Why you shouldn't use EXPLAIN

Not when bind variables are used.

> The second problem with using bind variables with the EXPLAIN PLAN statement is that no bind variable peeking is used. Because there’s no solution for that problem, it isn’t guaranteed that the execution plan generated by the EXPLAIN PLAN statement will be the one chosen at runtime. 
> In other words, whenever bind variables are involved, the output generated by the EXPLAIN PLAN statement is unreliable.

## What to do then ? 

Execution plans are also stored in the library cache, accessible through dynamic performance view. Query them to get execution plan of the query another session has run, or better use `dbms_dbms_xplan.display_cursor`.

### plan in dynamic performance views (in library cache)

Dynamic Performance Views : 
`v$sql_plan_statistics_all` is a single view for 
- `v$sql_plan` : same information as the plan table
- `v$sql_plan_statistics` :  execution statistics (runtime behavior), such as the elapsed time and the number of produced row
- `v$sql_workarea`: memory work areas needed to execute a cursor (estimation and runtime)

```oracle
SELECT *
FROM v$sql_plan_statistics_all
WHERE sql_id = '9xz7yas8z9pd9'
```

### Cursors

The cursors in the library cache (and therefore in these dynamic performance views) are identified by two columns: 
- address : identify the parent cursor, better using `sql_id` as it depends only on the SQL statement itself (never changes)
- child_number

> To identify a cursor, basically you’re confronted with two search methods:
>  - you know the session executing a SQL statement
>  - you know the text of the SQL statement

Once the child cursor (sql_id, child_number) is identified, you can display information about it.

If you know the session
```oracle
SELECT status, sql_id, sql_child_number
FROM v$session 
WHERE status = 'active';
```

If you know the text
```oracle
SELECT sql_id, child_number, sql_text
FROM v$sql
WHERE 1=1
    AND sql_fulltext LIKE '%online discount%'
    AND sql_text NOT LIKE '%v$sql%'
```


Once identified (`sql_id` and `child_number`):
- you can run queries on `v$sql_plan_statistics_all`
-  you can run  `dbms_xplan.display_cursor`


Pass `sql_id` and `child_number`
```oracle
SELECT * 
FROM 
    table(dbms_xplan.display_cursor('9xz7yas8z9pd9', 0));
```

You'll get a plan
```text
"SQL_ID  9xz7yas8z9pd9, child number 0"
-------------------------------------
SELECT MAX(id) FROM simple_table
 
Plan hash value: 1067509040
 
-----------------------------------------------------------------------------------
| Id  | Operation          | Name         | Rows  | Bytes | Cost (%CPU)| Time     |
-----------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |              |       |       |     3 (100)|          |
|   1 |  SORT AGGREGATE    |              |     1 |    13 |            |          |
|   2 |   TABLE ACCESS FULL| SIMPLE_TABLE |  1001 | 13013 |     3   (0)| 00:00:01 |
-----------------------------------------------------------------------------------
 
Note
-----
   - dynamic statistics used: dynamic sampling (level=2)
```

## Understanding query optimizer

> If you’re in serious difficulty because of the decisions made by the query optimizer and you want to understand what is going on, a query optimizer trace may help you. 

You can use :
- Event 10053
- dbms_sqldiag.dump_trace

> Independently of how you enabled the tracing, the query optimizer generates a trace file containing plenty of information about the work it carries out. 
> In it, you’ll find 
> - the execution environment determined by initialization parameters
> - system statistics
> - object statistics
> - estimations performed for the purpose of finding out the most efficient execution plan.


## Read execution plan : sections

### Basic columns

- Id : if the number is prefixed by an asterisk, predicate information is available later.
- Operation: eg. `TABLE ACCESS FULL` 
- Name: the object on which the operation is executed, eg. `T1`

### Estimations

- Rows : number of rows returned by the operation
- Bytes : amount of data returned by the operation
- TempSpc: amount of temporary space required by the operation.
- Cost (%CPU): percentage of CPU used, cumulated
- Time : amount of time needed to execute the operation (HH:MM:SS).

### Runtime

- Starts : number of times a specific operation was executed
- A-Rows : (actual) number of rows returned by the operation
- A-Time:  (actual) amount of time spent executing the operation (HH:MM:SS.FF)
- Buffers :  number of [logical reads](lexicon.md) 
- Reads: number of physical reads
- Writes: number of physical writes

### Query Block Name / Object Alias

### Outline
Set of hints, that should be sufficient to reproduce that particular execution plan.

### Peeked Binds (identified by position)

### Predicate Information

2 values:
- where they are used : line
- how they’re applied: access, filter or storage 


access predicate : locate rows by taking advantage of an efficient access structure 
- hash table in memory
- an index

filter predicate : applied only after the rows have already been extracted from the structure storing them

```oracle
SELECT t2.* 
FROM t1, t2 
WHERE 
     t1.n = t2.n 
  AND t1.id > :t1_id 
  AND t2.id BETWEEN :t2_id_min AND :t2_id_max
```

```text
---------------------------------------------------------------------------------------
| Id  | Operation                     | Name  | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT              |       |       |       |    15 (100)|          |
|*  1 |  FILTER                       |       |       |       |            |          |
|*  2 |   HASH JOIN                   |       |    14 |  7756 |    15   (7)| 00:00:01 |
|   3 |    TABLE ACCESS BY INDEX ROWID| T2    |    14 |  7392 |     4   (0)| 00:00:01 |
|*  4 |     INDEX RANGE SCAN          | T2_PK |    14 |       |     2   (0)| 00:00:01 |
|*  5 |    TABLE ACCESS FULL          | T1    |   876 | 22776 |    23   (0)| 00:00:01 |
---------------------------------------------------------------------------------------
```

```text
   1 - filter(:T2_ID_MIN<=:T2_ID_MAX)
   2 - access("T1"."N"="T2"."N")
   4 - access("T2"."ID">=:T2_ID_MIN AND "T2"."ID"<=:T2_ID_MAX)
   5 - filter("T1"."ID">:T1_ID)
```

We can read:
- t1 is read seq-scan and filter for id (filter)
- t2 is read using index, filter for id (access)
- hash join between those on n (access)
- then another filter on t2.id (filter)

### Column Projection Information

Which columns are returned as output when each operation is executed.
Used to grasp the `Bytes` values, amount of data returned.

```text
Column Projection Information (identified by operation id):
-----------------------------------------------------------
   3 - "T2"."ID"[NUMBER,22], "T2"."N"[NUMBER,22], "T2"."PAD"[VARCHAR2,1000]
   5 - "T1"."N"[NUMBER,22]
```

> In this case, it’s significant to note that 
> - while the table access at line 3 returns the id, n, and pad columns
> - the table access at line 5 returns only the n column. 

> For this reason:
> - even though more rows are returned from t1 than t2
> - the estimated amount of data for each row is greater in t2 than t1
> - cause
>   - line 3 :  7,392 bytes / 14 rows = 528 bytes 
>   - line 5 : 22,776 bytes / 876 rows = 26 bytes 


A database engine can partially read a row  if sensible for performance.

```text
---------------------------------------------------------------------------------------
| Id  | Operation                     | Name  | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------------------
|   3 |    TABLE ACCESS BY INDEX ROWID| T2    |    14 |  7392 |     4   (0)| 00:00:01 |
|*  5 |    TABLE ACCESS FULL          | T1    |   876 | 22776 |    23   (0)| 00:00:01 |
---------------------------------------------------------------------------------------
```

To select what to display

```oracle
EXPLAIN PLAN FOR
SELECT /*+ gather_plan_statistics */
MAX(id) FROM simple_table
WHERE id > 500
```

Use `format` parameter 
- use `typical`
- or  
  - set to `all` to get all (`advanced` gives actually all)
  - and remove what you don't need, eg. `-notes`

```oracle
SELECT *
FROM table( dbms_xplan.display (table_name   => NULL, 
                                statement_id => NULL, 
--                                 format       => 'basic'));
                                format       => 'typical'));
--                                 format       => 'all -projection -alias -note'));
```

## Read execution plan : steps

### Rules

Child node provide data to their parents using unix-like streams, following these rules:
> - Parent operations call child operations.
> - Child operations are fully executed before their parent operations.
> - Child operations pass data to their parent operations.

## Sample

> Knowing the parent-child relationship is essential to understanding the order in which operations of an execution plan are executed. In fact, parent operations, to fulfill their task, require data that is provided by their child operations. 
> As a result, even though execution starts at the root of the tree, the first operation to be fully executed is one that has no child and, therefore, is a leaf of the tree.

```text
---------------------------------------------
| Id  | Operation                    | Name |
---------------------------------------------
|   0 | SELECT STATEMENT             |      |
|   1 |  SORT ORDER BY               |      |
|   2 |   TABLE ACCESS BY INDEX ROWID| T    |
|   3 |    INDEX RANGE SCAN          | T_PK |
---------------------------------------------
```

> The operations are executed as follows:
> - The entry point of the execution plan is operation 0, the root of the tree. However, operation 0, a SELECT statement, has no data to work on. Hence, it has to call its child (1).
> - operation 1, a sort, has no data to work on. Hence, it has to call its child (2).
> - operation 2, a table access, requires rowids to access the t table. Hence, it has to call its child (3).

> - operation 3, an index access, requires no data from another operation (it has no child). Therefore, it carries out the index range scan on the t_pk index and passes the rowids it finds to its parent (2).
> - operation 2 uses the list of rowids it receives from its child (3) to access the t table. Then, it passes the resulting data to its parent (1).
> - operation 1 sorts the data passed by its child (2) and passes the resulting data to its parent (0).
> - operation 0 passes the data received from its child (1) to the caller.


> Even though the first operation being executed is always the root of the tree, parent operations (three in the previous case) may do nothing other than to invoke a child operation. So, for simplicity, I usually say that the execution starts with the first operation that can do some real work (this is operation 3 in the previous case).

## Operations (node)

4 types:
- stand-alone: at most one child, not iterative operation "child operation is executed at most once"
- iterative: at most one child, that can be executed more than once
- unrelated-combine operations
- related-combine operations

2 types:
- blocking : in bulk (eg. `sort`) =>  should be buffered in memory (PGA) or disk (temporary tablespace).
- nonblocking operations : row by row (eg. `=`)

### standalone

#### Rule
Child operation is executed at most once.

#### Sample
```oracle
SELECT deptno, count(*)
FROM emp
WHERE job = 'CLERK' AND sal < 1200
GROUP BY deptno 
```

```text
--------------------------------------------------------------------
| Id  | Operation                    | Name      | Starts | A-Rows |
--------------------------------------------------------------------
|   0 | SELECT STATEMENT             |           |      1 |      2 |
|   1 |  HASH GROUP BY               |           |      1 |      2 |
|*  2 |   TABLE ACCESS BY INDEX ROWID| EMP       |      1 |      3 |
|*  3 |    INDEX RANGE SCAN          | EMP_JOB_I |      1 |      4 |
--------------------------------------------------------------------

2 - filter("SAL"<1200)
3 - access("JOB"='CLERK')
```

You can see:
- each parent has exactly one child
- each node is executed exactly one time (`starts = 1`)

In full
> Operations 0, 1 and 2 have a single child each (1, 2 and 3, respectively); they can’t be the first operations being executed. Therefore, the execution starts with operation 3.
> Operation 3 scans the emp_job_i index by applying the "J0B"='CLERK' access predicate. In doing so, it extracts four rowids (this information is given in the A-Rows column) from the index and passes them to its parent (2).
> Operation 2 accesses the emp table through the four rowids passed from operation 3. For each rowid, a row is read. Then, it applies the "SAL"<1200 filter predicate. This filter leads to the exclusion of one row. The data of the remaining three rows is passed to its parent (1).
> Operation 1 performs a GROUP BY on the rows passed from operation 2. The resulting set is reduced to two rows and passed to its parent (0).
> Operation 0 sends the data to the caller.


#### Child skipping

> One of the rules states that child operations are entirely executed before parent operations. This is generally true, but there are situations where smart optimizations are introduced. hat can happen is that a parent decides that it makes no sense to completely execute a child or even that it makes no sense to execute it at all. In other words, parents control the execution of children.

`COUNT STOPKEY` is one such case: stop the processing as soon as the required number of rows has been returned to the caller.

```oracle
SELECT *
FROM emp
WHERE rownum <= 10
```

`COUNT STOPKEY` is such operation, stopping its children (fullscan id 2) when the required rows have been returned.
```text
-----------------------------------------------------
| Id  | Operation          | Name | Starts | A-Rows |
-----------------------------------------------------
|   0 | SELECT STATEMENT   |      |      1 |     10 |
|*  1 |  COUNT STOPKEY     |      |      1 |     10 |
|   2 |   TABLE ACCESS FULL| EMP  |      1 |     10 |
-----------------------------------------------------
 
   1 - filter(ROWNUM<=10)
```

! blocking operations can’t be stopped

```oracle
SELECT *
FROM (
       SELECT *
       FROM emp
       ORDER BY sal DESC
     )
WHERE rownum <= 10
```

`STOPKEY` is applied to `SORT`, but `SORT` has to process all 14 rows
```text
----------------------------------------------------------
| Id  | Operation               | Name | Starts | A-Rows |
----------------------------------------------------------
|   0 | SELECT STATEMENT        |      |      1 |     10 |
|*  1 |  COUNT STOPKEY          |      |      1 |     10 |
|   2 |   VIEW                  |      |      1 |     10 |
|*  3 |    SORT ORDER BY STOPKEY|      |      1 |     10 |
|   4 |     TABLE ACCESS FULL   | EMP  |      1 |     14 |
----------------------------------------------------------
 
   1 - filter(ROWNUM<=10)
   3 - filter(ROWNUM<=10)
```

Filter can skip child execution: this one is tricky !


```oracle
SELECT *
FROM emp
WHERE sal BETWEEN :sal_min AND :sal_max
```

```text
 
-----------------------------------------------------
| Id  | Operation          | Name | Starts | A-Rows |
-----------------------------------------------------
|   0 | SELECT STATEMENT   |      |      1 |      0 |
|*  1 |  FILTER            |      |      1 |      0 |
|*  2 |   TABLE ACCESS FULL| EMP  |      0 |      0 |
-----------------------------------------------------
 
   1 - filter(:SAL_MIN<=:SAL_MAX)
   2 - filter(("SAL"<=:SAL_MAX AND "SAL">=:SAL_MIN))
```

Operation 2 has been skipped (starts = 0), because ... bind variable actual values prevent the condition from ever be true: sal_min > sal_max. Data has no chance of going through the filter applied by operation 1 anyway.

### iterative

> You can consider them as operations that implement a sort of loop in an execution plan. 
> The INLIST ITERATOR and most of the operations that have the PARTITION suffix (for example, PARTITION RANGE ITERATOR) are of this type


#### Rule

A child operation may be executed several times or not executed at all.

#### Sample

```oracle
SELECT *
FROM emp
WHERE job IN ('CLERK', 'ANALYST')
```

Are executed 2 times (as many times as range values)
- index lookup: who is a clerk ? X and Y
- table read using index: gimme the rows for rowid X and Y
```text
 
--------------------------------------------------------------------
| Id  | Operation                    | Name      | Starts | A-Rows |
--------------------------------------------------------------------
|   0 | SELECT STATEMENT             |           |      1 |      6 |
|   1 |  INLIST ITERATOR             |           |      1 |      6 |
|   2 |   TABLE ACCESS BY INDEX ROWID| EMP       |      2 |      6 |
|*  3 |    INDEX RANGE SCAN          | EMP_JOB_I |      2 |      6 |
--------------------------------------------------------------------
 
   3 - access(("JOB"='ANALYST' OR "JOB"='CLERK'))
```